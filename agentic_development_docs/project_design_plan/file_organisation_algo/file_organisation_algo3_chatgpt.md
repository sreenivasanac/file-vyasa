Got it â€” hereâ€™s how to design a practical algorithm + LLM planning workflow to transform your current messy folder structure into the planned folder structure generated by the Folder Structure Planning Module (from your V1 spec).

ğŸ¯ Goal

Given:
	â€¢	Current directory structure (real filesystem snapshot)
	â€¢	Planned structure (LLM-generated folder hierarchy)
	â€¢	File summaries, metadata, and types

You want a structured and reliable LLM-assisted plan that says:
	â€¢	which folders to move wholesale,
	â€¢	which folders to merge,
	â€¢	which files to move individually, and
	â€¢	which to leave untouched.

ğŸ§© Algorithm Overview

Step 1. Data Collection (Deterministic Preprocessing)

Collect structured JSON-like context before invoking any LLM:

{
  "current_tree": { "path": "...", "folders": [...], "files": [...] },
  "planned_tree": { "path": "...", "folders": [...], "files": [...] },
  "file_summaries": { "filename": "summary text", "metadata": {...} },
  "rules": ["keep invoices under Finance", "merge similar media folders"]
}

Perform a DFS traversal on both trees to normalize:
	â€¢	folder path depth,
	â€¢	relative names,
	â€¢	file counts and types,
	â€¢	semantic hashes (e.g., embedding IDs for summaries).

ğŸ’¡ This step ensures reproducibility and diffability even before the LLM sees data.


Step 2. Structural Matching Heuristic (Non-LLM)

Before involving the model, run lightweight matching:
	â€¢	Compute a folder similarity score between each current folder and each planned folder:
Score = name_similarity + content_similarity + metadata_overlap
	â€¢	If score > threshold â†’ mark as â€œcandidate move target.â€

This filters out obvious mappings and reduces token use in LLM calls.


Step 3. LLM-Guided Move Plan Generation

Now that you have filtered candidates, the core planning happens here.

ğŸ”¹ Prompt Inputs
You call the LLM with:
	1.	Current folder JSON (simplified, not raw paths)
	2.	Planned folder JSON
	3.	File summaries + types + metadata (shortened)
	4.	Heuristic matches (your precomputed high-similarity pairs)
	5.	Explicit task prompt (see below)

ğŸ”¹ Prompt Template (Pseudo)
System: You are an expert file organization planner. Your goal is to map a messy current folder tree into a clean target structure. 
Follow these principles:
- Prefer moving entire folders when â‰¥70% of their files belong in one planned folder.
- Merge folders with similar content clusters.
- Suggest per-file moves only if the parent folder is mixed-topic.
- Never delete files.

User:
CURRENT TREE:
<json: current_tree>

PLANNED TREE:
<json: planned_tree>

FILE SUMMARIES (abridged):
<json: file_summaries>

HEURISTIC MATCHES:
<json: folder_similarity_candidates>

Rules:
<rules>

TASK:
Return structured JSON:
{
  "folder_moves": [{"from": "...", "to": "...", "confidence": 0.91, "reason": "..."}],
  "folder_merges": [{"source": "...", "target": "...", "reason": "..."}],
  "file_moves": [{"from": "...", "to": "...", "confidence": 0.87, "reason": "..."}],
  "unmoved_items": ["..."]
}


Step 4. Confidence Validation + Human-in-the-loop
	â€¢	Parse LLM JSON output and assign numeric confidence to each move.
	â€¢	If confidence >= 0.85 â†’ preselect as â€œlikely safe.â€
	â€¢	If 0.6â€“0.84 â†’ show for review.
	â€¢	If <0.6 â†’ flag as â€œneeds manual inspection.â€

Store this mapping in a SQLite-backed Approval State Manager (already defined in your spec).

Step 5. Merge Recommendation Pass (Optional)

Run a second pass where the LLM sees only ambiguous folders and the revised partial plan.
Prompt it to re-evaluate merges:


Given these uncertain folder mappings, refine your plan:
Only output additional merges or adjustments, not full re-mapping.

Step 6. Plan Finalization

Aggregate both passes into a final structured object:

{
  "final_plan": {
    "approved_folder_moves": [...],
    "approved_file_moves": [...],
    "pending_review": [...],
    "rejected": [...]
  },
  "rollback_ready_log": [...]
}


This object becomes your plan.json used by the Execution Module after user approval.

âš™ï¸ Summary of Techniques
1. DFS traversal + metadata collection -> Normalize input

2. Heuristic folder similarity (cosine, Levenshtein, file overlap)
Reduce LLM load

3. Structured LLM call (JSON-in/out) -> Generate move/merge plan

4. Confidence-based filtering -> Prioritize safe actions

5. Iterative refinement -> Handle uncertain mappings

6. Persistent plan object -> Enable rollback + audit trail


ğŸ§  Implementation Notes
	â€¢	Use chunked LLM calls per subdirectory to stay within token limits (e.g., per top-level folder).
	â€¢	Cache embeddings for file summaries to re-use across runs.
	â€¢	When calling the LLM, wrap the output in a JSON schema validator to guarantee structure.
	â€¢	Keep the human-in-the-loop review screen exactly aligned with this structured plan.

